"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var class_validator_1 = require("class-validator");
var class_transformer_1 = require("class-transformer");
function transformAndValidate(classType, somethingToTransform, options) {
    return new Promise(function (resolve, reject) {
        var object;
        if (typeof somethingToTransform === "string") {
            object = JSON.parse(somethingToTransform);
        }
        else if (somethingToTransform != null && typeof somethingToTransform === "object") {
            object = somethingToTransform;
        }
        else {
            return reject(new Error("Incorrect object param type! Only string, plain object and array of plain objects are valid."));
        }
        var classObject = class_transformer_1.plainToClass(classType, object, options ? options.transformer : void 0);
        if (Array.isArray(classObject)) {
            Promise.all(classObject.map(function (objectElement) { return class_validator_1.validate(objectElement, options ? options.validator : void 0); }))
                .then(function (errors) { return errors.every(function (error) { return error.length === 0; }) ? resolve(classObject) : reject(errors); });
        }
        else {
            class_validator_1.validateOrReject(classObject, options ? options.validator : void 0)
                .then(function () { return resolve(classObject); })
                .catch(reject);
        }
    });
}
exports.transformAndValidate = transformAndValidate;
function transformAndValidateSync(classType, somethingToTransform, options) {
    var object;
    if (typeof somethingToTransform === "string") {
        object = JSON.parse(somethingToTransform);
    }
    else if (somethingToTransform != null && typeof somethingToTransform === "object") {
        object = somethingToTransform;
    }
    else {
        throw new Error("Incorrect object param type! Only string, plain object and array of plain objects are valid.");
    }
    var classObject = class_transformer_1.plainToClass(classType, object, options ? options.transformer : void 0);
    if (Array.isArray(classObject)) {
        var errorsArray = classObject.map(function (objectElement) { return class_validator_1.validateSync(objectElement, options ? options.validator : void 0); });
        if (errorsArray.some(function (errors) { return errors.length !== 0; })) {
            throw errorsArray;
        }
        return classObject;
    }
    else {
        var errors = class_validator_1.validateSync(classObject, options ? options.validator : void 0);
        if (errors.length) {
            throw errors;
        }
        return classObject;
    }
}
exports.transformAndValidateSync = transformAndValidateSync;
//# sourceMappingURL=index.js.map